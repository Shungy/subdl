#!/bin/sh

usage="usage: ${0##*/} [-e episode] [-i imdbid] [-s season] [-l sublanguageid] [-n] [query]"
tmpfile=$(mktemp /tmp/subdl-XXXXXX)
trap 'rm "$tmpfile"' 0 1 15

url_encode() {
	# Query must be URL encoded to handle reserved characters.
	printf '%s' "$1" | tr '[:upper:]' '[:lower:]' | \
		printf "%%%s" $(od -v -t x1 -An -) # Do NOT quote!
}

check_num() {
	printf '%s' "$1" | grep '^[0-9]\+$' > /dev/null || {
		printf 'Season and episode must be natural numbers.\n'
		exit 1
	}
}

check_lang() {
	printf '%s' "$1" | grep '^[a-z]\{3\}\(,[a-z]\{3\}\)*$' > /dev/null || {
		printf 'Language code must be 3 letters.\n'
		printf 'Multiple languages must be separated with a comma.\n'
		exit 1
	}
}

check_imdbid() {
	printf '%s' "$1" | grep '^[0-9]\{7\}$' > /dev/null || {
		printf 'Imdbid must be 7 figures.\n'
		printf 'Imdbid must exclude property prefix.\n'
		exit 1
	}
}

check_args() {
	# Either a query or an imdbid must exist.
	[ -z "$1" ] && [ -z "$imdbid" ] && {
		printf '%s\n' "$usage"
		exit 1
	}
}

set_query() {
	# Strip the location prefix if the query is a file.
	if [ -f "$1" ]
	then
		url_encode "${1##*/}"
	elif [ -n "$1" ]
	then
		url_encode "$*"
	fi
}

set_addr() {
	# Print slash only when the relevant variable exists.
	printf 'http://rest.opensubtitles.org/search%s%s%s%s%s'    \
	       "${episode:+/episode-}${episode}"                   \
	       "${imdbid:+/imdbid-}${imdbid}"                      \
	       "${query:+/query-}${query}"                         \
	       "${season:+/season-}${season}"                      \
	       "${sublanguageid:+/sublanguageid-}${sublanguageid}"
}

display_results() {
	jq -e -j '
		. |
		if length == 0
		then
			"no result.\n" | halt_error
		else
			[[range(length) | tostring] ,
			[.[].SubFileName] , [.[].SubLanguageID]] |
			transpose | .[] | " " + .[0] + " [" + .[2] +
			"]: " + .[1] | . + "\n"
		end
	' "$tmpfile" || {
		# If there is a server error, the error message is displayed in
		# plain text instead of JSON. This causes jq to fail parsing the
		# server response. In that case the file is output to terminal
		# to show the error.
		cat "$tmpfile"
		exit 1
	}
}

ask_num() {
	printf "Subtitle number (Ctrl-c to cancel): "
	read -r num
	check_num "$num"
}

get_sub_info() {
	# Get the first result (number zero) if '-n flag' is supplied.
	# TODO: Check if the num exists
	jq -j --argjson num "${num:-0}" '
		.[$num] | [ .SubDownloadLink , "\t" , .SubFileName ] | .[]
	' "$tmpfile"
}

while getopts ne:i:s:l: opt
do
	# Set variables from command line options. Also do sanity
	# checks to not send an erronous request to the server.
	case $opt in
		n)
			# Download the first result
			dontask="1"
			;;
		e)
			check_num "$OPTARG"
			episode="$OPTARG"
			;;
		i)
			check_imdbid "$OPTARG"
			imdbid="$OPTARG"
			;;
		s)
			check_num "$OPTARG"
			season="$OPTARG"
			;;
		l)
			check_lang "$OPTARG"
			sublanguageid="$OPTARG"
			;;
		\?)
			printf '%s\n' "$usage"
			exit
			;;
	esac
done
shift $(( OPTIND - 1 ))

# Make sure that proper arguments are supplied.
check_args "$@"

# Define the 'query' and 'address' variables.
query=$(set_query "$@")
addr=$(set_addr)

# Get the query response page from the server.
curl -s -S -A 'TemporaryUserAgent' "$addr" > "$tmpfile"

# Display list of available subtitles by parsing the server response.
display_results

# Prompt for user input if '-n flag' is not provided.
[ -z "$dontask" ] && ask_num

# Parse the query response page one more time to get the download URL and
# the file name in a tab-delineated format.
IFS='	' # IFS='\t'
read -r dlurl filename << EOF
$(get_sub_info)
EOF

# Finally download the subtitle file.
curl -s -S "$dlurl" | gzip -d > "$filename" &&
	printf 'Fetched %s.\n' "$filename"
